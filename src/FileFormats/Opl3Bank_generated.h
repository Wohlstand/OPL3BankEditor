// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPL3BANK_H_
#define FLATBUFFERS_GENERATED_OPL3BANK_H_

#include "flatbuffers/flatbuffers.h"

struct Operator;

struct Instrument;

struct Bank;

struct Opl3Bank;

enum Mode {
  Mode_TwoOp = 0,
  Mode_FourOp = 1,
  Mode_Pseudo = 2,
  Mode_MIN = Mode_TwoOp,
  Mode_MAX = Mode_Pseudo
};

inline const Mode (&EnumValuesMode())[3] {
  static const Mode values[] = {
    Mode_TwoOp,
    Mode_FourOp,
    Mode_Pseudo
  };
  return values;
}

inline const char * const *EnumNamesMode() {
  static const char * const names[] = {
    "TwoOp",
    "FourOp",
    "Pseudo",
    nullptr
  };
  return names;
}

inline const char *EnumNameMode(Mode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMode()[index];
}

enum BankType {
  BankType_Melodic = 0,
  BankType_Percussion = 1,
  BankType_MIN = BankType_Melodic,
  BankType_MAX = BankType_Percussion
};

inline const BankType (&EnumValuesBankType())[2] {
  static const BankType values[] = {
    BankType_Melodic,
    BankType_Percussion
  };
  return values;
}

inline const char * const *EnumNamesBankType() {
  static const char * const names[] = {
    "Melodic",
    "Percussion",
    nullptr
  };
  return names;
}

inline const char *EnumNameBankType(BankType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBankType()[index];
}

enum VolumeModel {
  VolumeModel_Auto = 0,
  VolumeModel_Generic = 1,
  VolumeModel_Native = 2,
  VolumeModel_DMX = 3,
  VolumeModel_Apogee = 4,
  VolumeModel_Win9x = 5,
  VolumeModel_MIN = VolumeModel_Auto,
  VolumeModel_MAX = VolumeModel_Win9x
};

inline const VolumeModel (&EnumValuesVolumeModel())[6] {
  static const VolumeModel values[] = {
    VolumeModel_Auto,
    VolumeModel_Generic,
    VolumeModel_Native,
    VolumeModel_DMX,
    VolumeModel_Apogee,
    VolumeModel_Win9x
  };
  return values;
}

inline const char * const *EnumNamesVolumeModel() {
  static const char * const names[] = {
    "Auto",
    "Generic",
    "Native",
    "DMX",
    "Apogee",
    "Win9x",
    nullptr
  };
  return names;
}

inline const char *EnumNameVolumeModel(VolumeModel e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesVolumeModel()[index];
}

MANUALLY_ALIGNED_STRUCT(1) Operator FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t AVEKM_;
  uint8_t KSLL_;
  uint8_t AtDec_;
  uint8_t SusRel_;
  uint8_t WaveForm_;

 public:
  Operator() {
    memset(this, 0, sizeof(Operator));
  }
  Operator(uint8_t _AVEKM, uint8_t _KSLL, uint8_t _AtDec, uint8_t _SusRel, uint8_t _WaveForm)
      : AVEKM_(flatbuffers::EndianScalar(_AVEKM)),
        KSLL_(flatbuffers::EndianScalar(_KSLL)),
        AtDec_(flatbuffers::EndianScalar(_AtDec)),
        SusRel_(flatbuffers::EndianScalar(_SusRel)),
        WaveForm_(flatbuffers::EndianScalar(_WaveForm)) {
  }
  uint8_t AVEKM() const {
    return flatbuffers::EndianScalar(AVEKM_);
  }
  uint8_t KSLL() const {
    return flatbuffers::EndianScalar(KSLL_);
  }
  uint8_t AtDec() const {
    return flatbuffers::EndianScalar(AtDec_);
  }
  uint8_t SusRel() const {
    return flatbuffers::EndianScalar(SusRel_);
  }
  uint8_t WaveForm() const {
    return flatbuffers::EndianScalar(WaveForm_);
  }
};
STRUCT_END(Operator, 5);

struct Instrument FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROGRAM = 4,
    VT_NAME = 6,
    VT_KEYOFFSET1 = 8,
    VT_KEYOFFSET2 = 10,
    VT_VELOCITYOFFSET = 12,
    VT_SECONDVOICETUNING = 14,
    VT_PERCUSSIONKEY = 16,
    VT_MODE = 18,
    VT_BLANK = 20,
    VT_FB_CONN1 = 22,
    VT_FB_CONN2 = 24,
    VT_MODULATOR1 = 26,
    VT_CARRIER1 = 28,
    VT_MODULATOR2 = 30,
    VT_CARRIER2 = 32,
    VT_KONMS = 34,
    VT_KOFFMS = 36
  };
  uint8_t program() const {
    return GetField<uint8_t>(VT_PROGRAM, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t keyOffset1() const {
    return GetField<int16_t>(VT_KEYOFFSET1, 0);
  }
  int16_t keyOffset2() const {
    return GetField<int16_t>(VT_KEYOFFSET2, 0);
  }
  int8_t velocityOffset() const {
    return GetField<int8_t>(VT_VELOCITYOFFSET, 0);
  }
  int8_t secondVoiceTuning() const {
    return GetField<int8_t>(VT_SECONDVOICETUNING, 0);
  }
  uint8_t percussionKey() const {
    return GetField<uint8_t>(VT_PERCUSSIONKEY, 0);
  }
  Mode mode() const {
    return static_cast<Mode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool blank() const {
    return GetField<uint8_t>(VT_BLANK, 0) != 0;
  }
  uint8_t fb_conn1() const {
    return GetField<uint8_t>(VT_FB_CONN1, 0);
  }
  uint8_t fb_conn2() const {
    return GetField<uint8_t>(VT_FB_CONN2, 0);
  }
  const Operator *modulator1() const {
    return GetStruct<const Operator *>(VT_MODULATOR1);
  }
  const Operator *carrier1() const {
    return GetStruct<const Operator *>(VT_CARRIER1);
  }
  const Operator *modulator2() const {
    return GetStruct<const Operator *>(VT_MODULATOR2);
  }
  const Operator *carrier2() const {
    return GetStruct<const Operator *>(VT_CARRIER2);
  }
  uint16_t konMs() const {
    return GetField<uint16_t>(VT_KONMS, 0);
  }
  uint16_t koffMs() const {
    return GetField<uint16_t>(VT_KOFFMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PROGRAM) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int16_t>(verifier, VT_KEYOFFSET1) &&
           VerifyField<int16_t>(verifier, VT_KEYOFFSET2) &&
           VerifyField<int8_t>(verifier, VT_VELOCITYOFFSET) &&
           VerifyField<int8_t>(verifier, VT_SECONDVOICETUNING) &&
           VerifyField<uint8_t>(verifier, VT_PERCUSSIONKEY) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint8_t>(verifier, VT_BLANK) &&
           VerifyField<uint8_t>(verifier, VT_FB_CONN1) &&
           VerifyField<uint8_t>(verifier, VT_FB_CONN2) &&
           VerifyField<Operator>(verifier, VT_MODULATOR1) &&
           VerifyField<Operator>(verifier, VT_CARRIER1) &&
           VerifyField<Operator>(verifier, VT_MODULATOR2) &&
           VerifyField<Operator>(verifier, VT_CARRIER2) &&
           VerifyField<uint16_t>(verifier, VT_KONMS) &&
           VerifyField<uint16_t>(verifier, VT_KOFFMS) &&
           verifier.EndTable();
  }
};

struct InstrumentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_program(uint8_t program) {
    fbb_.AddElement<uint8_t>(Instrument::VT_PROGRAM, program, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Instrument::VT_NAME, name);
  }
  void add_keyOffset1(int16_t keyOffset1) {
    fbb_.AddElement<int16_t>(Instrument::VT_KEYOFFSET1, keyOffset1, 0);
  }
  void add_keyOffset2(int16_t keyOffset2) {
    fbb_.AddElement<int16_t>(Instrument::VT_KEYOFFSET2, keyOffset2, 0);
  }
  void add_velocityOffset(int8_t velocityOffset) {
    fbb_.AddElement<int8_t>(Instrument::VT_VELOCITYOFFSET, velocityOffset, 0);
  }
  void add_secondVoiceTuning(int8_t secondVoiceTuning) {
    fbb_.AddElement<int8_t>(Instrument::VT_SECONDVOICETUNING, secondVoiceTuning, 0);
  }
  void add_percussionKey(uint8_t percussionKey) {
    fbb_.AddElement<uint8_t>(Instrument::VT_PERCUSSIONKEY, percussionKey, 0);
  }
  void add_mode(Mode mode) {
    fbb_.AddElement<int8_t>(Instrument::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_blank(bool blank) {
    fbb_.AddElement<uint8_t>(Instrument::VT_BLANK, static_cast<uint8_t>(blank), 0);
  }
  void add_fb_conn1(uint8_t fb_conn1) {
    fbb_.AddElement<uint8_t>(Instrument::VT_FB_CONN1, fb_conn1, 0);
  }
  void add_fb_conn2(uint8_t fb_conn2) {
    fbb_.AddElement<uint8_t>(Instrument::VT_FB_CONN2, fb_conn2, 0);
  }
  void add_modulator1(const Operator *modulator1) {
    fbb_.AddStruct(Instrument::VT_MODULATOR1, modulator1);
  }
  void add_carrier1(const Operator *carrier1) {
    fbb_.AddStruct(Instrument::VT_CARRIER1, carrier1);
  }
  void add_modulator2(const Operator *modulator2) {
    fbb_.AddStruct(Instrument::VT_MODULATOR2, modulator2);
  }
  void add_carrier2(const Operator *carrier2) {
    fbb_.AddStruct(Instrument::VT_CARRIER2, carrier2);
  }
  void add_konMs(uint16_t konMs) {
    fbb_.AddElement<uint16_t>(Instrument::VT_KONMS, konMs, 0);
  }
  void add_koffMs(uint16_t koffMs) {
    fbb_.AddElement<uint16_t>(Instrument::VT_KOFFMS, koffMs, 0);
  }
  explicit InstrumentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstrumentBuilder &operator=(const InstrumentBuilder &);
  flatbuffers::Offset<Instrument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instrument>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instrument> CreateInstrument(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t program = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t keyOffset1 = 0,
    int16_t keyOffset2 = 0,
    int8_t velocityOffset = 0,
    int8_t secondVoiceTuning = 0,
    uint8_t percussionKey = 0,
    Mode mode = Mode_TwoOp,
    bool blank = false,
    uint8_t fb_conn1 = 0,
    uint8_t fb_conn2 = 0,
    const Operator *modulator1 = 0,
    const Operator *carrier1 = 0,
    const Operator *modulator2 = 0,
    const Operator *carrier2 = 0,
    uint16_t konMs = 0,
    uint16_t koffMs = 0) {
  InstrumentBuilder builder_(_fbb);
  builder_.add_carrier2(carrier2);
  builder_.add_modulator2(modulator2);
  builder_.add_carrier1(carrier1);
  builder_.add_modulator1(modulator1);
  builder_.add_name(name);
  builder_.add_koffMs(koffMs);
  builder_.add_konMs(konMs);
  builder_.add_keyOffset2(keyOffset2);
  builder_.add_keyOffset1(keyOffset1);
  builder_.add_fb_conn2(fb_conn2);
  builder_.add_fb_conn1(fb_conn1);
  builder_.add_blank(blank);
  builder_.add_mode(mode);
  builder_.add_percussionKey(percussionKey);
  builder_.add_secondVoiceTuning(secondVoiceTuning);
  builder_.add_velocityOffset(velocityOffset);
  builder_.add_program(program);
  return builder_.Finish();
}

inline flatbuffers::Offset<Instrument> CreateInstrumentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t program = 0,
    const char *name = nullptr,
    int16_t keyOffset1 = 0,
    int16_t keyOffset2 = 0,
    int8_t velocityOffset = 0,
    int8_t secondVoiceTuning = 0,
    uint8_t percussionKey = 0,
    Mode mode = Mode_TwoOp,
    bool blank = false,
    uint8_t fb_conn1 = 0,
    uint8_t fb_conn2 = 0,
    const Operator *modulator1 = 0,
    const Operator *carrier1 = 0,
    const Operator *modulator2 = 0,
    const Operator *carrier2 = 0,
    uint16_t konMs = 0,
    uint16_t koffMs = 0) {
  return CreateInstrument(
      _fbb,
      program,
      name ? _fbb.CreateString(name) : 0,
      keyOffset1,
      keyOffset2,
      velocityOffset,
      secondVoiceTuning,
      percussionKey,
      mode,
      blank,
      fb_conn1,
      fb_conn2,
      modulator1,
      carrier1,
      modulator2,
      carrier2,
      konMs,
      koffMs);
}

struct Bank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_BANKLSB = 8,
    VT_BANKMSB = 10,
    VT_INSTRUMENTS = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  BankType type() const {
    return static_cast<BankType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint8_t bankLSB() const {
    return GetField<uint8_t>(VT_BANKLSB, 0);
  }
  uint8_t bankMSB() const {
    return GetField<uint8_t>(VT_BANKMSB, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Instrument>> *instruments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Instrument>> *>(VT_INSTRUMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_BANKLSB) &&
           VerifyField<uint8_t>(verifier, VT_BANKMSB) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.Verify(instruments()) &&
           verifier.VerifyVectorOfTables(instruments()) &&
           verifier.EndTable();
  }
};

struct BankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Bank::VT_NAME, name);
  }
  void add_type(BankType type) {
    fbb_.AddElement<int8_t>(Bank::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_bankLSB(uint8_t bankLSB) {
    fbb_.AddElement<uint8_t>(Bank::VT_BANKLSB, bankLSB, 0);
  }
  void add_bankMSB(uint8_t bankMSB) {
    fbb_.AddElement<uint8_t>(Bank::VT_BANKMSB, bankMSB, 0);
  }
  void add_instruments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instrument>>> instruments) {
    fbb_.AddOffset(Bank::VT_INSTRUMENTS, instruments);
  }
  explicit BankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BankBuilder &operator=(const BankBuilder &);
  flatbuffers::Offset<Bank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bank> CreateBank(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    BankType type = BankType_Melodic,
    uint8_t bankLSB = 0,
    uint8_t bankMSB = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instrument>>> instruments = 0) {
  BankBuilder builder_(_fbb);
  builder_.add_instruments(instruments);
  builder_.add_name(name);
  builder_.add_bankMSB(bankMSB);
  builder_.add_bankLSB(bankLSB);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bank> CreateBankDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    BankType type = BankType_Melodic,
    uint8_t bankLSB = 0,
    uint8_t bankMSB = 0,
    const std::vector<flatbuffers::Offset<Instrument>> *instruments = nullptr) {
  return CreateBank(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      type,
      bankLSB,
      bankMSB,
      instruments ? _fbb.CreateVector<flatbuffers::Offset<Instrument>>(*instruments) : 0);
}

struct Opl3Bank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INTERNALVERSION = 4,
    VT_OPLTV = 6,
    VT_VOLUMEMODEL = 8,
    VT_BANKS = 10
  };
  uint16_t internalVersion() const {
    return GetField<uint16_t>(VT_INTERNALVERSION, 0);
  }
  uint8_t oplTV() const {
    return GetField<uint8_t>(VT_OPLTV, 0);
  }
  VolumeModel volumeModel() const {
    return static_cast<VolumeModel>(GetField<uint8_t>(VT_VOLUMEMODEL, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Bank>> *banks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bank>> *>(VT_BANKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_INTERNALVERSION) &&
           VerifyField<uint8_t>(verifier, VT_OPLTV) &&
           VerifyField<uint8_t>(verifier, VT_VOLUMEMODEL) &&
           VerifyOffset(verifier, VT_BANKS) &&
           verifier.Verify(banks()) &&
           verifier.VerifyVectorOfTables(banks()) &&
           verifier.EndTable();
  }
};

struct Opl3BankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_internalVersion(uint16_t internalVersion) {
    fbb_.AddElement<uint16_t>(Opl3Bank::VT_INTERNALVERSION, internalVersion, 0);
  }
  void add_oplTV(uint8_t oplTV) {
    fbb_.AddElement<uint8_t>(Opl3Bank::VT_OPLTV, oplTV, 0);
  }
  void add_volumeModel(VolumeModel volumeModel) {
    fbb_.AddElement<uint8_t>(Opl3Bank::VT_VOLUMEMODEL, static_cast<uint8_t>(volumeModel), 0);
  }
  void add_banks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bank>>> banks) {
    fbb_.AddOffset(Opl3Bank::VT_BANKS, banks);
  }
  explicit Opl3BankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Opl3BankBuilder &operator=(const Opl3BankBuilder &);
  flatbuffers::Offset<Opl3Bank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Opl3Bank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Opl3Bank> CreateOpl3Bank(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t internalVersion = 0,
    uint8_t oplTV = 0,
    VolumeModel volumeModel = VolumeModel_Auto,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bank>>> banks = 0) {
  Opl3BankBuilder builder_(_fbb);
  builder_.add_banks(banks);
  builder_.add_internalVersion(internalVersion);
  builder_.add_volumeModel(volumeModel);
  builder_.add_oplTV(oplTV);
  return builder_.Finish();
}

inline flatbuffers::Offset<Opl3Bank> CreateOpl3BankDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t internalVersion = 0,
    uint8_t oplTV = 0,
    VolumeModel volumeModel = VolumeModel_Auto,
    const std::vector<flatbuffers::Offset<Bank>> *banks = nullptr) {
  return CreateOpl3Bank(
      _fbb,
      internalVersion,
      oplTV,
      volumeModel,
      banks ? _fbb.CreateVector<flatbuffers::Offset<Bank>>(*banks) : 0);
}

inline const Opl3Bank *GetOpl3Bank(const void *buf) {
  return flatbuffers::GetRoot<Opl3Bank>(buf);
}

inline const Opl3Bank *GetSizePrefixedOpl3Bank(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Opl3Bank>(buf);
}

inline bool VerifyOpl3BankBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Opl3Bank>(nullptr);
}

inline bool VerifySizePrefixedOpl3BankBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Opl3Bank>(nullptr);
}

inline void FinishOpl3BankBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Opl3Bank> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedOpl3BankBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Opl3Bank> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_OPL3BANK_H_
